package cl.agj.extra.geometry {
	import flash.geom.Point;
	
	public class Segment {
		
		static public const INTERSECTING:String = "intersecting";
		static public const COINCIDENT:String = "coincident";
		static public const PARALLEL:String = "parallel";
		static public const NOT_INTERSECTING:String = "notIntersecting";
		
		public var a:Point;
		public var b:Point;
		
		public function Segment(a:Point, b:Point) {
			this.a = a;
			this.b = b;
		}
		
		/////
		
		public function get length():Number {
			if (!a || !b)
				return NaN;
			return Point.distance(a, b);
		}
		
		/////
		
		/**
		 * @param against       Segment to intersect against.
		 * @param intersection  Point to be set with the value of the intersection.
		 * @param asLines       Checks against the line generated by extending the segments to infinity.
		 * 
		 * @return              One of the Segment constants INTERSECTING, NOT_INTERSECTING, COINCIDENT, or PARALLEL.
		 */
		public function intersect(against:Segment, intersection:Point, asLines:Boolean = false):String {
			// Code adapted from Adam Coventry's C++, found at: http://paulbourke.net/geometry/pointlineplane/
			
			var denom:Number = ((against.b.y - against.a.y)*(b.x - a.x)) -
				((against.b.x - against.a.x)*(b.y - a.y));
			
			var nume_a:Number = ((against.b.x - against.a.x)*(a.y - against.a.y)) -
				((against.b.y - against.a.y)*(a.x - against.a.x));
			
			var nume_b:Number = ((b.x - a.x)*(a.y - against.a.y)) -
				((b.y - a.y)*(a.x - against.a.x));
			
			if (denom === 0) {
				if (nume_a === 0 && nume_b === 0) {
					return COINCIDENT;
				}
				return PARALLEL;
			}
			
			var ua:Number = nume_a / denom;
			var ub:Number = nume_b / denom;
			
			if (asLines || (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) ) {
				// Get the intersection point.
				intersection.x = a.x + ua*(b.x - a.x);
				intersection.y = a.y + ua*(b.y - a.y);
				
				return INTERSECTING;
			}
			
			return NOT_INTERSECTING;
		}
		
	}
}